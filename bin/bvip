#!/usr/bin/env bash

# @describe BreachVIP API client for breach data search
# @arg term "Search term to look up" [string]
# @arg fields* "Fields to search (ip, domain, steamid, name, uuid, username, email, discordid, phone, password)" [string]
# @option -c --categories "Categories to filter by (only 'minecraft' supported currently)" [string]
# @flag   -w --wildcard "Enable wildcard search (* and ? operators)"
# @flag   -s --case-sensitive "Enable case-sensitive search"
# @flag   -j --json "Output raw JSON instead of formatted results"
# @flag   -q --quiet "Suppress colored output"
# @meta require-tools curl,jq

# ARGC-BUILD {
# This block was generated by argc (https://github.com/sigoden/argc).
# Modifying it manually is not recommended

_argc_run() {
    if [[ "${1:-}" == "___internal___" ]]; then
        _argc_die "error: unsupported ___internal___ command"
    fi
    if [[ "${OS:-}" == "Windows_NT" ]] && [[ -n "${MSYSTEM:-}" ]]; then
        set -o igncr
    fi
    argc__args=("$(basename "$0" .sh)" "$@")
    argc__positionals=()
    _argc_index=1
    _argc_len="${#argc__args[@]}"
    _argc_tools=()
    _argc_parse
    _argc_require_tools "${_argc_tools[@]}"
    if [ -n "${argc__fn:-}" ]; then
        $argc__fn "${argc__positionals[@]}"
    fi
}

_argc_usage() {
    cat <<-'EOF'
BreachVIP API client for breach data search

USAGE: bvip [OPTIONS] [TERM] [FIELDS]...

ARGS:
  [TERM]       "Search term to look up" [string]
  [FIELDS]...  "Fields to search (ip, domain, steamid, name, uuid, username, email, discordid, phone, password)" [string]

OPTIONS:
  -c, --categories <CATEGORIES>  "Categories to filter by (only 'minecraft' supported currently)" [string]
  -w, --wildcard                 "Enable wildcard search (* and ? operators)"
  -s, --case-sensitive           "Enable case-sensitive search"
  -j, --json                     "Output raw JSON instead of formatted results"
  -q, --quiet                    "Suppress colored output"
  -h, --help                     Print help
  -V, --version                  Print version
EOF
    exit
}

_argc_version() {
    echo bvip 0.0.0
    exit
}

_argc_parse() {
    local _argc_key _argc_action
    local _argc_subcmds=""
    while [[ $_argc_index -lt $_argc_len ]]; do
        _argc_item="${argc__args[_argc_index]}"
        _argc_key="${_argc_item%%=*}"
        case "$_argc_key" in
        --help | -help | -h)
            _argc_usage
            ;;
        --version | -version | -V)
            _argc_version
            ;;
        --)
            _argc_dash="${#argc__positionals[@]}"
            argc__positionals+=("${argc__args[@]:$((_argc_index + 1))}")
            _argc_index=$_argc_len
            break
            ;;
        --categories | -c)
            _argc_take_args "--categories <CATEGORIES>" 1 1 "-" ""
            _argc_index=$((_argc_index + _argc_take_args_len + 1))
            if [[ -z "${argc_categories:-}" ]]; then
                argc_categories="${_argc_take_args_values[0]:-}"
            else
                _argc_die "error: the argument \`--categories\` cannot be used multiple times"
            fi
            ;;
        --wildcard | -w)
            if [[ "$_argc_item" == *=* ]]; then
                _argc_die "error: flag \`--wildcard\` don't accept any value"
            fi
            _argc_index=$((_argc_index + 1))
            if [[ -n "${argc_wildcard:-}" ]]; then
                _argc_die "error: the argument \`--wildcard\` cannot be used multiple times"
            else
                argc_wildcard=1
            fi
            ;;
        --case-sensitive | -s)
            if [[ "$_argc_item" == *=* ]]; then
                _argc_die "error: flag \`--case-sensitive\` don't accept any value"
            fi
            _argc_index=$((_argc_index + 1))
            if [[ -n "${argc_case_sensitive:-}" ]]; then
                _argc_die "error: the argument \`--case-sensitive\` cannot be used multiple times"
            else
                argc_case_sensitive=1
            fi
            ;;
        --json | -j)
            if [[ "$_argc_item" == *=* ]]; then
                _argc_die "error: flag \`--json\` don't accept any value"
            fi
            _argc_index=$((_argc_index + 1))
            if [[ -n "${argc_json:-}" ]]; then
                _argc_die "error: the argument \`--json\` cannot be used multiple times"
            else
                argc_json=1
            fi
            ;;
        --quiet | -q)
            if [[ "$_argc_item" == *=* ]]; then
                _argc_die "error: flag \`--quiet\` don't accept any value"
            fi
            _argc_index=$((_argc_index + 1))
            if [[ -n "${argc_quiet:-}" ]]; then
                _argc_die "error: the argument \`--quiet\` cannot be used multiple times"
            else
                argc_quiet=1
            fi
            ;;
        *)
            if _argc_maybe_flag_option "-" "$_argc_item"; then
                _argc_die "error: unexpected argument \`$_argc_key\` found"
            fi
            argc__positionals+=("$_argc_item")
            _argc_index=$((_argc_index + 1))
            ;;
        esac
    done
    _argc_tools=(curl jq)
    if [[ -n "${_argc_action:-}" ]]; then
        $_argc_action
    else
        if [[ "${argc__positionals[0]:-}" == "help" ]] && [[ "${#argc__positionals[@]}" -eq 1 ]]; then
            _argc_usage
        fi
        _argc_match_positionals 0 1
        local values_index values_size
        IFS=: read -r values_index values_size <<<"${_argc_match_positionals_values[0]:-}"
        if [[ -n "$values_index" ]]; then
            argc_term="${argc__positionals[values_index]}"
        fi
        IFS=: read -r values_index values_size <<<"${_argc_match_positionals_values[1]:-}"
        if [[ -n "$values_index" ]]; then
            argc_fields=("${argc__positionals[@]:values_index:values_size}")
        fi
    fi
}

_argc_take_args() {
    _argc_take_args_values=()
    _argc_take_args_len=0
    local param="$1" min="$2" max="$3" signs="$4" delimiter="$5"
    if [[ "$min" -eq 0 ]] && [[ "$max" -eq 0 ]]; then
        return
    fi
    local _argc_take_index=$((_argc_index + 1)) _argc_take_value
    if [[ "$_argc_item" == *=* ]]; then
        _argc_take_args_values=("${_argc_item##*=}")
    else
        while [[ $_argc_take_index -lt $_argc_len ]]; do
            _argc_take_value="${argc__args[_argc_take_index]}"
            if _argc_maybe_flag_option "$signs" "$_argc_take_value"; then
                if [[ "${#_argc_take_value}" -gt 1 ]]; then
                    break
                fi
            fi
            _argc_take_args_values+=("$_argc_take_value")
            _argc_take_args_len=$((_argc_take_args_len + 1))
            if [[ "$_argc_take_args_len" -ge "$max" ]]; then
                break
            fi
            _argc_take_index=$((_argc_take_index + 1))
        done
    fi
    if [[ "${#_argc_take_args_values[@]}" -lt "$min" ]]; then
        _argc_die "error: incorrect number of values for \`$param\`"
    fi
    if [[ -n "$delimiter" ]] && [[ "${#_argc_take_args_values[@]}" -gt 0 ]]; then
        local item values arr=()
        for item in "${_argc_take_args_values[@]}"; do
            IFS="$delimiter" read -r -a values <<<"$item"
            arr+=("${values[@]}")
        done
        _argc_take_args_values=("${arr[@]}")
    fi
}

_argc_match_positionals() {
    _argc_match_positionals_values=()
    _argc_match_positionals_len=0
    local params=("$@")
    local args_len="${#argc__positionals[@]}"
    if [[ $args_len -eq 0 ]]; then
        return
    fi
    local params_len=$# arg_index=0 param_index=0
    while [[ $param_index -lt $params_len && $arg_index -lt $args_len ]]; do
        local takes=0
        if [[ "${params[param_index]}" -eq 1 ]]; then
            if [[ $param_index -eq 0 ]] &&
                [[ ${_argc_dash:-} -gt 0 ]] &&
                [[ $params_len -eq 2 ]] &&
                [[ "${params[$((param_index + 1))]}" -eq 1 ]] \
                ; then
                takes=${_argc_dash:-}
            else
                local arg_diff=$((args_len - arg_index)) param_diff=$((params_len - param_index))
                if [[ $arg_diff -gt $param_diff ]]; then
                    takes=$((arg_diff - param_diff + 1))
                else
                    takes=1
                fi
            fi
        else
            takes=1
        fi
        _argc_match_positionals_values+=("$arg_index:$takes")
        arg_index=$((arg_index + takes))
        param_index=$((param_index + 1))
    done
    if [[ $arg_index -lt $args_len ]]; then
        _argc_match_positionals_values+=("$arg_index:$((args_len - arg_index))")
    fi
    _argc_match_positionals_len=${#_argc_match_positionals_values[@]}
    if [[ $params_len -gt 0 ]] && [[ $_argc_match_positionals_len -gt $params_len ]]; then
        local index="${_argc_match_positionals_values[params_len]%%:*}"
        _argc_die "error: unexpected argument \`${argc__positionals[index]}\` found"
    fi
}

_argc_maybe_flag_option() {
    local signs="$1" arg="$2"
    if [[ -z "$signs" ]]; then
        return 1
    fi
    local cond=false
    if [[ "$signs" == *"+"* ]]; then
        if [[ "$arg" =~ ^\+[^+].* ]]; then
            cond=true
        fi
    elif [[ "$arg" == -* ]]; then
        if (( ${#arg} < 3 )) || [[ ! "$arg" =~ ^---.* ]]; then
            cond=true
        fi
    fi
    if [[ "$cond" == "false" ]]; then
        return 1
    fi
    local value="${arg%%=*}"
    if [[ "$value" =~ [[:space:]] ]]; then
        return 1
    fi
    return 0
}

_argc_require_tools() {
    local tool missing_tools=()
    for tool in "$@"; do
        if ! command -v "$tool" >/dev/null 2>&1; then
            missing_tools+=("$tool")
        fi
    done
    if [[ "${#missing_tools[@]}" -gt 0 ]]; then
        echo "error: missing tools: ${missing_tools[*]}" >&2
        exit 1
    fi
}

_argc_die() {
    if [[ $# -eq 0 ]]; then
        cat
    else
        echo "$*" >&2
    fi
    exit 1
}

_argc_run "$@"

# ARGC-BUILD }

setup_colors() {
  if [ "$argc_quiet" = 1 ] || [ -z "$TERM" ] || [ "$TERM" = "dumb" ]; then
    bold="" reset="" blue="" green="" yellow="" cyan="" magenta="" red=""
  else
    if command -v tput >/dev/null 2>&1 && [ -n "$TERM" ]; then
      bold=$(tput bold 2>/dev/null || printf '\033[1m')
      reset=$(tput sgr0 2>/dev/null || printf '\033[0m')
      blue=$(tput setaf 4 2>/dev/null || printf '\033[34m')
      green=$(tput setaf 2 2>/dev/null || printf '\033[32m')
      yellow=$(tput setaf 3 2>/dev/null || printf '\033[33m')
      cyan=$(tput setaf 6 2>/dev/null || printf '\033[36m')
      magenta=$(tput setaf 5 2>/dev/null || printf '\033[35m')
      red=$(tput setaf 1 2>/dev/null || printf '\033[31m')
    else
      bold='\033[1m'
      reset='\033[0m'
      blue='\033[34m'
      green='\033[32m'
      yellow='\033[33m'
      cyan='\033[36m'
      magenta='\033[35m'
      red='\033[31m'
    fi
  fi
}
setup_colors

API_BASE="https://breach.vip"

print_kv() {
  printf "${bold}%s:${reset} %s\n" "$1" "$2"
}

print_section() {
  printf "\n${bold}%s:${reset}\n" "$1"
}

format_case() {
  echo "$(tr '[:lower:]' '[:upper:]' <<<${1:0:1})${1:1}"
}

make_request() {
  local payload="$1"
  local temp_file=$(mktemp)

  local http_code=$(curl -s -X POST \
    -H "Content-Type: application/json" \
    -d "$payload" \
    -w "%{http_code}" \
    -o "$temp_file" \
    "${API_BASE}/api/search")

  local response=$(cat "$temp_file")
  rm -f "$temp_file"

  if [ -z "$http_code" ] || [ "$http_code" = "000" ]; then
    printf "${red}Error:${reset} Connection failed - check network connectivity to %s\n" "$API_BASE" >&2
    exit 1
  fi

  if [ "$http_code" -ne 200 ]; then
    case "$http_code" in
    400)
      error_msg=$(echo "$response" | jq -r '.error // "Bad request"' 2>/dev/null || echo "Bad request")
      printf "${red}Error:${reset} Bad request: ${red}%s${reset}\n" "$error_msg" >&2
      ;;
    405)
      printf "${red}Error:${reset} Method not allowed\n" >&2
      ;;
    500)
      printf "${red}Error:${reset} Internal server error\n" >&2
      ;;
    *)
      printf "${red}Error:${reset} HTTP %s\n" "$http_code" >&2
      if [ -n "$response" ]; then
        printf "Response: %s\n" "$response" >&2
      fi
      ;;
    esac
    exit 1
  fi

  echo "$response"
}

validate_categories() {
  local categories="$1"
  if [ -n "$categories" ] && [ "$categories" != "minecraft" ]; then
    echo "${red}Error:${reset} Invalid category '${categories}'. Only 'minecraft' is currently supported." >&2
    exit 1
  fi
}

validate_term() {
  local term="$1"
  local wildcard="$2"

  if [ ${#term} -lt 1 ] || [ ${#term} -gt 99 ]; then
    echo "${red}Error:${reset} Search term must be between 1 and 99 characters" >&2
    exit 1
  fi

  if [ "$wildcard" = 1 ]; then
    if [[ "$term" =~ ^[\*\?] ]]; then
      echo "${red}Error:${reset} Wildcard search terms cannot begin with * or ?" >&2
      exit 1
    fi
  fi
}

show_help() {
  printf "\n${bold}${magenta}BREACH VIP CLIENT${reset} ${yellow}🔍${reset}\n"
  printf "${cyan}Breach database search across multiple field types${reset}\n\n"

  printf "${bold}${green}USAGE${reset}\n"
  printf "  ${cyan}$(basename "$0")${reset} ${yellow}<term>${reset} ${green}<fields...>${reset} ${blue}[options]${reset}\n\n"

  printf "${bold}${green}FIELDS${reset}\n"
  printf "  ${yellow}ip${reset}           Search in IP addresses\n"
  printf "  ${yellow}domain${reset}       Search in domain names\n"
  printf "  ${yellow}steamid${reset}      Search in Steam IDs\n"
  printf "  ${yellow}name${reset}         Search in names\n"
  printf "  ${yellow}uuid${reset}         Search in UUIDs\n"
  printf "  ${yellow}username${reset}     Search in usernames\n"
  printf "  ${yellow}email${reset}        Search in email addresses\n"
  printf "  ${yellow}discordid${reset}    Search in Discord IDs\n"
  printf "  ${yellow}phone${reset}        Search in phone numbers\n"
  printf "  ${yellow}password${reset}     Search in passwords\n\n"

  printf "${bold}${yellow}OPTIONS${reset}\n"
  printf "  ${yellow}-w, --wildcard${reset}       Enable wildcards (* and ?)\n"
  printf "  ${yellow}-s, --case-sensitive${reset} Enable case-sensitive search\n"
  printf "  ${yellow}-c, --categories${reset}     Filter by categories (minecraft only)\n"
  printf "  ${yellow}-j, --json${reset}           Output raw JSON\n"
  printf "  ${yellow}-q, --quiet${reset}          Suppress colored output\n\n"

  printf "${bold}${red}WILDCARD PATTERNS${reset}\n"
  printf "  ${yellow}*${reset}  Match ${bold}zero or more${reset} characters\n"
  printf "  ${yellow}?${reset}  Match ${bold}exactly one${reset} character\n\n"

  printf "${bold}${green}EXAMPLES${reset}\n"
  printf "  ${cyan}Search for email:${reset}\n"
  printf "    ${green}\$${reset} ${cyan}$(basename "$0")${reset} ${yellow}john.doe@example.com${reset} ${green}email${reset}\n\n"

  printf "  ${cyan}Search across multiple fields:${reset}\n"
  printf "    ${green}\$${reset} ${cyan}$(basename "$0")${reset} ${yellow}192.168.1.1${reset} ${green}ip email username${reset}\n\n"

  printf "  ${cyan}Search by Steam ID:${reset}\n"
  printf "    ${green}\$${reset} ${cyan}$(basename "$0")${reset} ${yellow}76561198000000000${reset} ${green}steamid${reset}\n\n"

  printf "  ${cyan}Search by Discord ID:${reset}\n"
  printf "    ${green}\$${reset} ${cyan}$(basename "$0")${reset} ${yellow}123456789012345678${reset} ${green}discordid${reset}\n\n"

  printf "  ${cyan}Search by domain:${reset}\n"
  printf "    ${green}\$${reset} ${cyan}$(basename "$0")${reset} ${yellow}example.com${reset} ${green}domain${reset}\n\n"

  printf "  ${cyan}Search by phone number:${reset}\n"
  printf "    ${green}\$${reset} ${cyan}$(basename "$0")${reset} ${yellow}\"+1-555-0123\"${reset} ${green}phone${reset}\n\n"

  printf "  ${cyan}Search by UUID:${reset}\n"
  printf "    ${green}\$${reset} ${cyan}$(basename "$0")${reset} ${yellow}550e8400-e29b-41d4-a716-446655440000${reset} ${green}uuid${reset}\n\n"

  printf "  ${cyan}Wildcard email search:${reset}\n"
  printf "    ${green}\$${reset} ${cyan}$(basename "$0")${reset} ${yellow}\"john*@example.com\"${reset} ${green}email${reset} ${blue}--wildcard${reset}\n\n"

  printf "  ${cyan}Search username with pattern:${reset}\n"
  printf "    ${green}\$${reset} ${cyan}$(basename "$0")${reset} ${yellow}\"admin*\"${reset} ${green}username${reset} ${blue}--wildcard${reset}\n\n"

  printf "  ${cyan}With category filter:${reset}\n"
  printf "    ${green}\$${reset} ${cyan}$(basename "$0")${reset} ${yellow}\"user@minecraft.net\"${reset} ${green}email${reset} ${blue}--categories${reset} minecraft\n\n"

  printf "  ${cyan}JSON output:${reset}\n"
  printf "    ${green}\$${reset} ${cyan}$(basename "$0")${reset} ${yellow}test123${reset} ${green}username password${reset} ${blue}--json${reset}\n\n"
}

format_search_results() {
  local response="$1"

  if [ -z "$response" ] || ! echo "$response" | jq empty 2>/dev/null; then
    printf "${red}Error:${reset} Invalid response from server\n" >&2
    return 1
  fi

  local results_count=$(echo "$response" | jq -r '.results | length' 2>/dev/null || echo "0")

  if [ -z "$results_count" ] || [ "$results_count" -eq 0 ]; then
    printf "${yellow}No results found${reset}\n"
    return
  fi

  printf "${bold}Found ${green}%s${reset} result(s):\n\n" "$results_count"

  echo "$response" | jq -r '.results | group_by(.source) | .[] | "\(.[0].source)|\(length)|\(. | tostring)"' |
    while IFS="|" read -r source count items_json; do
      printf "${bold}${blue}%s${reset} (${yellow}%s${reset} record(s))\n" "$source" "$count"

      echo "$items_json" | jq -r '.[] | @json' | while read -r item; do
        local categories=$(echo "$item" | jq -r 'if .categories | type == "array" then .categories | join(", ") else .categories end')

        printf "  ${cyan}Categories:${reset} ${magenta}%s${reset}\n" "$categories"

        echo "$item" | jq -r 'to_entries | map(select(.key != "source" and .key != "categories")) | .[] | "\(.key)|\(.value)"' |
          while IFS="|" read -r key value; do
            case "$key" in
            "password")
              printf "  ${cyan}%s:${reset} ${red}%s${reset}\n" "$(format_case "$key")" "$value"
              ;;
            "email")
              printf "  ${cyan}%s:${reset} ${green}%s${reset}\n" "$(format_case "$key")" "$value"
              ;;
            "ip")
              printf "  ${cyan}%s:${reset} ${blue}%s${reset}\n" "$(format_case "$key")" "$value"
              ;;
            "domain")
              printf "  ${cyan}%s:${reset} ${blue}%s${reset}\n" "$(format_case "$key")" "$value"
              ;;
            "steamid")
              printf "  ${cyan}%s:${reset} ${yellow}%s${reset}\n" "Steam ID" "$value"
              ;;
            "discordid")
              printf "  ${cyan}%s:${reset} ${magenta}%s${reset}\n" "Discord ID" "$value"
              ;;
            "phone")
              printf "  ${cyan}%s:${reset} ${green}%s${reset}\n" "$(format_case "$key")" "$value"
              ;;
            "uuid")
              printf "  ${cyan}%s:${reset} ${cyan}%s${reset}\n" "UUID" "$value"
              ;;
            *)
              printf "  ${cyan}%s:${reset} %s\n" "$(format_case "$key")" "$value"
              ;;
            esac
          done
        printf "\n"
      done
      printf "\n"
    done
}

if [ -z "$argc_term" ]; then
  show_help
  exit 0
fi

if [ ${#argc_fields[@]} -eq 0 ]; then
  echo "${red}Error:${reset} At least one field type must be specified" >&2
  echo "Valid fields: ip, domain, steamid, name, uuid, username, email, discordid, phone, password" >&2
  echo "Usage: $(basename "$0") <term> <fields...> [options]" >&2
  exit 1
fi

valid_fields=("ip" "domain" "steamid" "name" "uuid" "username" "email" "discordid" "phone" "password")
for field in "${argc_fields[@]}"; do
  if ! [[ " ${valid_fields[@]} " =~ " ${field} " ]]; then
    echo "${red}Error:${reset} Invalid field type '${field}'" >&2
    echo "Valid fields: ip, domain, steamid, name, uuid, username, email, discordid, phone, password" >&2
    exit 1
  fi
done

validate_term "$argc_term" "$argc_wildcard"
validate_categories "$argc_categories"

fields_json=$(printf '%s\n' "${argc_fields[@]}" | jq -R . | jq -s .)

payload="{\"term\":\"$argc_term\",\"fields\":$fields_json"

if [ "$argc_wildcard" = 1 ]; then
  payload="$payload,\"wildcard\":true"
fi

if [ "$argc_case_sensitive" = 1 ]; then
  payload="$payload,\"case_sensitive\":true"
fi

if [ -n "$argc_categories" ]; then
  payload="$payload,\"categories\":[\"$argc_categories\"]"
fi

payload="$payload}"

response=$(make_request "$payload")

if [ "$argc_json" = 1 ]; then
  echo "$response" | jq
else
  format_search_results "$response"
fi
